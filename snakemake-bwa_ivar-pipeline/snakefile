from os import listdir
from os.path import isfile, join
import pandas as pd

# Specify config file
configfile: "config.yaml"

# Set variables
in_dir = config['in_dir']
out_dir = config['out_dir']
sample = config['sample']

# Read barcode file
bc = pd.read_csv(config['bc'], sep = ",", header = None)

rule all:
    input:
        expand(out_dir + sample + "/consensus_sequences/{bc}.fa",
               bc = bc.iloc[:,0])

# Rule for extracting barcodes from read and appending them to head
if config['lanesplit']:
    lanes = ["L001", "L002", "L003", "L004"]

    # Rule for extracting barcodes from read and appending them to head
    if config['paired']:
        rule demux:
            input:
                fastq1=in_dir + sample + "_{lane}_R1.fastq.gz",
                fastq2=in_dir + sample + "_{lane}_R2.fastq.gz",
                barcodes=config['bc'],
            output:
                fastq1=temp(expand(out_dir + sample + "/demultiplexed_{{lane}}/{bc}_R1.fastq",
                    bc = bc.iloc[:,0])),
                fastq2=temp(expand(out_dir + sample + "/demultiplexed_{{lane}}/{bc}_R2.fastq",
                    bc = bc.iloc[:,0])),
                unassigned1=temp(out_dir + sample + "/demultiplexed_{lane}/unassigned_R1.fastq"),
                unassigned2=temp(out_dir + sample + "/demultiplexed_{lane}/unassigned_R2.fastq"),
                logfile=temp(out_dir + sample + "_{lane}_log.txt")
            params:
                outdir=out_dir + sample + "/demultiplexed_{lane}/",
                mismatches=config['mm']
            shell:
                config['demux'] + " -f {input.fastq1} -f2 {input.fastq2} --paired "
                "-o {params.outdir} -l {output.logfile} -b {input.barcodes} "
                "-m {params.mismatches}"

        rule concatenateFastq:
            input:
                f1=expand(out_dir + sample + "/demultiplexed_{lane}/{{bc}}_R1.fastq",
                          lane=lanes),
                f2=expand(out_dir + sample + "/demultiplexed_{lane}/{{bc}}_R2.fastq",
                          lane=lanes)
            output:
                f1=out_dir + sample + "/demultiplexed/{bc}_R1.fastq.gz",
                f2=out_dir + sample + "/demultiplexed/{bc}_R2.fastq.gz"
            threads: config['threads']
            shell:
                """
                cat {input.f1} | pigz -c -p {threads} > {output.f1};
                cat {input.f2} | pigz -c -p {threads} > {output.f2}
                """

        rule concatenateUnassigned:
            input:
                f1=expand(out_dir + sample + "/demultiplexed_{lane}/unassigned_R1.fastq",
                       lane=lanes),
                f2=expand(out_dir + sample + "/demultiplexed_{lane}/unassigned_R2.fastq",
                       lane=lanes)
            output:
                f1=out_dir + sample + "/demultiplexed/unassigned_R1.fastq.gz",
                f2=out_dir + sample + "/demultiplexed/unassigned_R2.fastq.gz"
            threads: config['threads']
            shell:
                """
                cat {input.f1} | pigz -c -p {threads} > {output.f1};
                cat {input.f2} | pigz -c -p {threads} > {output.f2}
                """

        # Aligning
        rule bwa:
            input:
                ref=config['ref'],
                fastq1=out_dir + sample + "/demultiplexed/{bc}_R1.fastq.gz",
                fastq2=out_dir + sample + "/demultiplexed/{bc}_R2.fastq.gz"
            output:
                bam=temp(out_dir + sample + "/bamfiles/{bc}.bam"),
                bai=temp(out_dir + sample + "/bamfiles/{bc}.bam.bai")
            params:
                rg=r"@RG\tID:{bc}\tSM:{bc}\tPL:ILLUMINA"
            threads: config['threads']
            shell:
                "bwa mem -M -t {threads} -R '{params.rg}' {input} | "
                "samtools sort -o {output.bam} && "
                "samtools index -@ {threads} {output.bam}"
    else:
        rule demux:
            input:
                fastq=in_dir + sample + "_{lane}_R1.fastq.gz",
                barcodes=config['bc'],
            output:
                fastq=temp(expand(out_dir + sample + "/demultiplexed_{{lane}}/{bc}.fastq",
                    bc = bc.iloc[:,0])),
                unassigned=temp(out_dir + sample + "/demultiplexed_{lane}/unassigned.fastq"),
                logfile=temp(out_dir + sample + "_{lane}_log.txt")
            params:
                outdir=out_dir + sample + "/demultiplexed_{lane}/",
                mismatches=config['mm']
            shell:
                config['demux'] + " -f {input.fastq} -o {params.outdir} "
                "-l {output.logfile} -b {input.barcodes} -m {params.mismatches} "
                "--barcode_length {params.barcode_length}"

        rule concatenateFastq:
            input:
                expand(out_dir + sample + "/demultiplexed_{lane}/{{bc}}.fastq",
                       lane=lanes)
            output:
                out_dir + sample + "/demultiplexed/{bc}.fastq.gz"
            threads: config['threads']
            shell:
                "cat {input} | pigz -c -p {threads} > {output}"


        rule concatenateUnassigned:
            input:
                expand(out_dir + sample + "/demultiplexed_{lane}/unassigned.fastq",
                    lane=lanes)
            output:
                out_dir + sample + "/demultiplexed/unassigned.fastq.gz"
            threads: config['threads']
            shell:
                "cat {input} | pigz -c -p {threads} > {output}"

        # Aligning
        rule bwa:
            input:
                ref=config['ref'],
                fastq=out_dir + sample + "/demultiplexed/{bc}.fastq.gz"
            output:
                bam=temp(out_dir + sample + "/bamfiles/{bc}.bam"),
                bai=temp(out_dir + sample + "/bamfiles/{bc}.bam.bai")
            params:
                rg=r"@RG\tID:{bc}\tSM:{bc}\tPL:ILLUMINA"
            threads: config['threads']
            shell:
                "bwa mem -M -t {threads} -R '{params.rg}' {input} | "
                "samtools sort -o {output.bam} && "
                "samtools index -@ {threads} {output.bam}"

else:
    # Rule for extracting barcodes from read and appending them to head
    if config['paired']:
        rule demux:
            input:
                fastq1=in_dir + sample + "_R1.fastq.gz",
                fastq2=in_dir + sample + "_R2.fastq.gz",
                barcodes=config['bc'],
            output:
                fastq1=temp(expand(out_dir + sample + "/demultiplexed/{bc}_R1.fastq",
                    bc = bc.iloc[:,0])),
                fastq2=temp(expand(out_dir + sample + "/demultiplexed/{bc}_R2.fastq",
                    bc = bc.iloc[:,0])),
                unassigned1=temp(out_dir + sample + "/demultiplexed/unassigned_R1.fastq"),
                unassigned2=temp(out_dir + sample + "/demultiplexed/unassigned_R2.fastq"),
                logfile=out_dir + sample + "_log.txt"
            params:
                outdir=out_dir + sample + "/demultiplexed/",
                mismatches=config['mm']
            shell:
                config['demux'] + " --fastq {input.fastq1} --fastq2 {input.fastq2} "
                "--paired -o {params.outdir} -l {output.logfile} -b {input.barcodes} "
                "-m {params.mismatches}"

        # Gzip output of demux
        rule pigz:
            input:
                expand(out_dir + sample + "/demultiplexed/{bc}_R1.fastq",
                    bc = bc.iloc[:,0]),
                expand(out_dir + sample + "/demultiplexed/{bc}_R2.fastq",
                    bc = bc.iloc[:,0]),
                out_dir + sample + "/demultiplexed/unassigned_R1.fastq",
                out_dir + sample + "/demultiplexed/unassigned_R2.fastq"
            output:
                expand(out_dir + sample + "/demultiplexed/{bc}_R1.fastq.gz",
                    bc = bc.iloc[:,0]),
                expand(out_dir + sample + "/demultiplexed/{bc}_R2.fastq.gz",
                    bc = bc.iloc[:,0]),
                out_dir + sample + "/demultiplexed/unassigned_R1.fastq.gz",
                out_dir + sample + "/demultiplexed/unassigned_R2.fastq.gz"
            threads: config['threads']
            shell:
                "pigz -p {threads} {input}"

        # Aligning
        rule bwa:
            input:
                ref=config['ref'],
                fastq1=out_dir + sample + "/demultiplexed/{bc}_R1.fastq.gz",
                fastq2=out_dir + sample + "/demultiplexed/{bc}_R2.fastq.gz"
            output:
                bam=temp(out_dir + sample + "/bamfiles/{bc}.bam"),
                bai=temp(out_dir + sample + "/bamfiles/{bc}.bam.bai")
            params:
                rg=r"@RG\tID:{bc}\tSM:{bc}\tPL:ILLUMINA"
            threads: config['threads']
            shell:
                "bwa mem -M -t {threads} -R '{params.rg}' {input} | "
                "samtools sort -o {output.bam} && "
                "samtools index -@ {threads} {output.bam}"

    else:
        rule demux:
            input:
                fastq=in_dir + sample + "_R1.fastq.gz",
                barcodes=config['bc'],
            output:
                fastq=temp(expand(out_dir + sample + "/demultiplexed/{bc}.fastq",
                    bc = bc.iloc[:,0])),
                unassigned=temp(out_dir + sample + "/demultiplexed/unassigned.fastq"),
                logfile=out_dir + sample + "_log.txt"
            params:
                outdir=out_dir + sample + "/demultiplexed/",
                mismatches=config['mm']
            shell:
                config['demux'] + " -f {input.fastq} -o {params.outdir} "
                "-l {output.logfile} -b {input.barcodes} -m {params.mismatches}"

        # Gzip output of demux
        rule pigz:
            input:
                expand(out_dir + sample + "/demultiplexed/{bc}.fastq",
                    bc = bc.iloc[:,0]),
                out_dir + sample + "/demultiplexed/unassigned.fastq"
            output:
                expand(out_dir + sample + "/demultiplexed/{bc}.fastq.gz",
                    bc = bc.iloc[:,0])
            threads: config['threads']
            shell:
                "pigz -p {threads} {input}"

        # Aligning
        rule bwa:
            input:
                ref=config['ref'],
                fastq=out_dir + sample + "/demultiplexed/{bc}.fastq.gz"
            output:
                bam=temp(out_dir + sample + "/bamfiles/{bc}.bam"),
                bai=temp(out_dir + sample + "/bamfiles/{bc}.bam.bai")
            params:
                rg=r"@RG\tID:{bc}\tSM:{bc}\tPL:ILLUMINA"
            threads: config['threads']
            shell:
                "bwa mem -M -t {threads} -R '{params.rg}' {input} | "
                "samtools sort -o {output.bam} && "
                "samtools index -@ {threads} {output.bam}"



# Filter reads based on readname using gatk
if config['paired']:
    # Get readnames of reads that mapped within cutsite range
    # and map to chr 1:22, X or Y
    rule getReads:
        input:
            bam=out_dir + sample + "/bamfiles/{bc}.bam",
            cutsites=config['cutsites']
        output:
            temp(out_dir + sample + "/bamfiles/{bc}_readnames.txt")
        params:
            readlength = config["readlength"]
        shell:
            config['getReads'] + " -b {input.bam} -c {input.cutsites} "
            "-o {output} --readlength {params} --paired"

    rule filterReads:
        input:
            bam=out_dir + sample + "/bamfiles/{bc}.bam",
            bai=out_dir + sample + "/bamfiles/{bc}.bam.bai",
            readnames=out_dir + sample + "/bamfiles/{bc}_readnames.txt"
        output:
            bam=temp(out_dir + sample + "/bamfiles/{bc}_filtered.bam"),
            bai=temp(out_dir + sample + "/bamfiles/{bc}_filtered.bai"),
            log=out_dir + sample + "/logs/{bc}-cutsite-filter.log"
        shell:
            """
            gatk FilterSamReads -I {input.bam} -O {output.bam} \\
            -RLF {input.readnames} --FILTER includeReadList --CREATE_INDEX true &&

            echo "pre cutsite-distance filter reads: " \\
            $(samtools view -c -f 64 -F 260 {input.bam}) > {output.log}

            echo "post cutsite-distance filter reads: " \\
            $(samtools view -c -f 64 -F 260 {output.bam}) >> {output.log}
            """
else:
    # Get readnames of reads that mapped within cutsite range
    # and map to chr 1:22, X or Y
    rule getReads:
        input:
            bam=out_dir + sample + "/bamfiles/{bc}.bam",
            cutsites=config['cutsites']
        output:
            temp(out_dir + sample + "/bamfiles/{bc}_readnames.txt")
        params:
            readlength = config["readlength"]
        shell:
            config['getReads'] + " -b {input.bam} -c {input.cutsites} -o {output} --readlength {params}"

    rule filterReads:
        input:
            bam=out_dir + sample + "/bamfiles/{bc}.bam",
            bai=out_dir + sample + "/bamfiles/{bc}.bam.bai",
            readnames=out_dir + sample + "/bamfiles/{bc}_readnames.txt"
        output:
            bam=temp(out_dir + sample + "/bamfiles/{bc}_filtered.bam"),
            bai=temp(out_dir + sample + "/bamfiles/{bc}_filtered.bai"),
            log=out_dir + sample + "/logs/{bc}-cutsite-filter.log"
        shell:
            """
            gatk FilterSamReads -I {input.bam} -O {output.bam} \\
            -RLF {input.readnames} --FILTER includeReadList --CREATE_INDEX true &&

            echo "pre cutsite-distance filter reads: " \\
            $(samtools view -c -F 260 {input.bam}) > {output.log}

            echo "post cutsite-distance filter reads: " \\
            $(samtools view -c -F 260 {output.bam}) >> {output.log}
            """
            
# Trim primer quality
rule trim_primer_quality:
    input:
        bam=out_dir + sample + "/bamfiles/{bc}_filtered.bam",
        bed=config['bed']
    output:
        bam_tmp=temp(out_dir + sample + "/trimmed/{bc}.trimmed.bam"),
        bam=protected(out_dir + sample + "/trimmed/{bc}.trimmed.sorted.bam"),
        bambai=out_dir + sample + "/trimmed/{bc}.trimmed.sorted.bam.bai"
    shell:
        """
        ivar trim -e -b {input.bed} -p {output.bam_tmp} -i {input.bam} &&
        samtools sort -o {output.bam} {output.bam_tmp} &&
        samtools index {output.bam}
        """
'''
# Deduplicate
rule deduplication:
    input:
        bam=out_dir + sample + "/trimmed/{bc}.trimmed.sorted.bam",
        index=out_dir + sample + "/trimmed/{bc}.trimmed.sorted.bam.bai"
    output:
        bam=protected(out_dir + sample + "/bamfiles/{bc}.trimmed.sorted.dedup.bam"),
        bai=out_dir + sample + "/bamfiles/{bc}.trimmed.sorted.dedup.bam.bai",
        log=out_dir + sample + "/logs/{bc}-deduplication.log"
    threads: 4
    shell:
        """
        umi_tools dedup -I {input.bam} -S {output.bam} -L {output.log} &&
        samtools index -@ {threads} {output.bam}
        """
'''
# Call consensus sequence on non deduplicated bamfile
rule call_consensus:
    input:
        out_dir + sample + "/trimmed/{bc}.trimmed.sorted.bam"
    output:
        fa=protected(out_dir + sample + "/consensus_sequences/{bc}.fa"),
        qual=protected(out_dir + sample + "/consensus_sequences/{bc}.qual.txt")
    shell:
        """
        samtools mpileup -A -d 0 -Q 0 -F 0 {input} | \
        ivar consensus -p {output.fa} -n N -m 10
        """
